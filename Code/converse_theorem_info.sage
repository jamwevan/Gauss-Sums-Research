# This file was *autogenerated* from the file converse_theorem_info.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2)
_sage_const_0 = Integer(0)
_sage_const_1 = Integer(1)
_sage_const_3 = Integer(3)
_sage_const_100 = Integer(100)

from sage.all import is_prime, carmichael_lambda, GF, expand
from collections import defaultdict

# -------------------------------------------------------------------------
# Compute the highest power of l dividing N
# -------------------------------------------------------------------------
def max_power(N, l):
    m = _sage_const_0
    while N % l == _sage_const_0:
        N //= l
        m += _sage_const_1
    return m

# -------------------------------------------------------------------------
# Partition an identical theta group by i mod (q-1)
# e.g. [2,6,10,14] => [[2,14], [6], [10]]
# -------------------------------------------------------------------------
def partition_by_mod_q_minus_1(group, q):
    mod_dict = defaultdict(list)
    for i in group:
        mod_val = i % (q - _sage_const_1)
        mod_dict[mod_val].append(i)
    subgroups = []
    for mod_val in sorted(mod_dict.keys()):
        subgroups.append(sorted(mod_dict[mod_val]))
    return subgroups

# -------------------------------------------------------------------------
# Convert a Python list to a curly-brace string
# e.g. [2,6,10,14] => {2,6,10,14}
# -------------------------------------------------------------------------
def list_to_curly_str(lst):
    return "{" + ",".join(str(x) for x in lst) + "}"

# -------------------------------------------------------------------------
# Convert a list of lists into comma-separated curly-brace subgroups
# e.g. [[2,14],[6],[10]] => {2,14}, {6}, {10}
# No outer braces around the entire set
# -------------------------------------------------------------------------
def subgroups_to_curly_str(subgroups):
    pieces = []
    for s in subgroups:
        pieces.append(list_to_curly_str(s))
    return ", ".join(pieces)

# -------------------------------------------------------------------------
# GaussSumTable Class (with reduced ranges for theta, alpha)
# -------------------------------------------------------------------------
class GaussSumTable:
    def __init__(self, q, additive_character_generator, multiplicative_character_generator, l):
        self.q = q
        self.l = l  # store prime l for range adjustments
        self.additive_character_generator = additive_character_generator
        self.multiplicative_character_generator = multiplicative_character_generator
        self.finite_field = GF(q**_sage_const_2)
        self.generator = self.finite_field.gen()
        self.finite_field_elements = list(self.finite_field)
        self.finite_field_multiplicative_group = [
            x for x in self.finite_field_elements if x != _sage_const_0
        ]
        
        # Compute new ranges for theta and alpha by removing the l-power factors
        N_theta = q**_sage_const_2 - _sage_const_1   # order of F_{q^2}^*
        m_theta = max_power(N_theta, l)
        self.theta_range = N_theta // (l**m_theta)
        
        N_alpha = q - _sage_const_1  # order of F_q^*
        m_alpha = max_power(N_alpha, l)
        self.alpha_range = N_alpha // (l**m_alpha)
        
        # Create the table with adjusted dimensions
        self.table = [
            [_sage_const_0 for _ in range(self.alpha_range)]
            for _ in range(self.theta_range)
        ]
        self.compute_gauss_sum_table()

    def compute_gauss_sum_table(self):
        for theta in range(self.theta_range):
            for alpha in range(self.alpha_range):
                self.table[theta][alpha] = self.compute_gauss_sum(theta, alpha)

    def compute_gauss_sum(self, theta, alpha):
        total = _sage_const_0
        for x in self.finite_field_multiplicative_group:
            additive_character_value = self.additive_character_generator**self.trace(x)
            theta_character_value = self.multiplicative_character_generator**(theta * self.log(x))
            alpha_character_value = self.multiplicative_character_generator**(
                alpha * self.get_norm_log(x)
            )
            total += (
                additive_character_value
                * theta_character_value
                * alpha_character_value
            )
        return total

    def get_norm_log(self, x):
        return (self.q + _sage_const_1) * self.log(x)

    def log(self, x):
        return x.log(self.generator) if x != _sage_const_0 else _sage_const_0

    def trace(self, x):
        return x.trace()

    def find_identical_rows(self):
        n = len(self.table)
        visited = set()
        groups = []
        for i in range(n):
            if i in visited:
                continue
            group = [i]
            visited.add(i)
            for j in range(i + _sage_const_1, n):
                if j in visited:
                    continue
                match = True
                for k in range(len(self.table[i])):
                    if expand(self.table[i][k] - self.table[j][k]) != _sage_const_0:
                        match = False
                        break
                if match:
                    group.append(j)
                    visited.add(j)
            if len(group) > _sage_const_1:
                groups.append(group)
        return groups

    def find_counterexamples(self, l, q):
        counterexamples = []
        if (q - _sage_const_1) % l == _sage_const_0:
            identical_groups = self.find_identical_rows()
            if identical_groups:
                identical_groups = sorted(identical_groups, key=len, reverse=True)
                counterexamples.append((l, q, identical_groups))
        return counterexamples

# -------------------------------------------------------------------------
# Build the Gauss sum table
# -------------------------------------------------------------------------
def fL_bar_gauss_sum_table(q, l):
    if not is_prime(l):
        raise ValueError("l must be a prime number!")
    prime_power_result = q.is_prime_power(get_data=True)
    if prime_power_result[1] == 0:
        raise ValueError("Expected a prime power!")
    p = prime_power_result[0]
    N = p * (q*q - 1)
    m = max_power(N, l)
    N_prime = N // (l**m)
    c = carmichael_lambda(N_prime)
    F = GF(l**c)
    h = F.gen()
    return GaussSumTable(
        q,
        h**((l**c - 1) // p),
        h**((p * (l**c - 1)) // N_prime),
        l
    )

# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
if __name__ == "__main__":
    l = Integer(input("Enter a prime l: "))
    q = Integer(input("Enter a prime power q: "))

    gauss_sum_table_object = fL_bar_gauss_sum_table(q, l)
    counterexamples = gauss_sum_table_object.find_counterexamples(l, q)

    print("\nCounterexamples where the converse theorem fails:")
    for l_val, q_val, identical_groups in counterexamples:
        print(f"l = {l_val}, q = {q_val}")
        print("\nIdentical Theta Groups (Sorted by Size):")
        print("-" * 120)
        # Column headers:
        #   1) Identical Theta Group
        #   2) Group Size
        #   3) theta_1 % (q-1) = theta_2 % (q-1) Subgroups
        #   4) Subgroup Size
        print(
            f"{'Identical Theta Group':<30}"
            f"{'Group Size':<12}"
            f"{'theta_1 % (q-1) = theta_2 % (q-1) Subgroups':<50}"
            f"{'Subgroup Size'}"
        )
        print("-" * 120)

        for group in identical_groups:
            # Convert group to curly braces
            group_str = list_to_curly_str(group)
            size_of_group = len(group)

            # Partition the group by i mod (q-1)
            mod_subgroups = partition_by_mod_q_minus_1(group, q)
            mod_subgroups_str = subgroups_to_curly_str(mod_subgroups)

            # The largest subgroup is the maximum length among the sub-lists
            largest_subgroup_size = max(len(s) for s in mod_subgroups)

            print(
                f"{group_str:<30}"
                f"{str(size_of_group):<12}"
                f"{mod_subgroups_str:<50}"
                f"{largest_subgroup_size}"
            )
        print("-" * 120)
