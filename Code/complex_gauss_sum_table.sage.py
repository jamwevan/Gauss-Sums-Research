

# This file was *autogenerated* from the file complex_gauss_sum_table.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
from sage.all import GF, e, pi, I, latex, is_prime  # Import required functions

class GaussSumTable:
    def __init__(self, q, additive_character_generator, multiplicative_character_generator):
        self.q = q
        self.additive_character_generator = additive_character_generator
        self.multiplicative_character_generator = multiplicative_character_generator

        self.finite_field = GF(q**_sage_const_2 )  # Corrected exponentiation syntax
        self.generator = self.finite_field.gen()
        self.finite_field_elements = list(self.finite_field)
        self.finite_field_multiplicative_group = [x for x in self.finite_field_elements if x != _sage_const_0 ]

        self.table = [[_sage_const_0  for _ in range(q - _sage_const_1 )] for _ in range(q**_sage_const_2  - _sage_const_1 )]
        self.compute_gauss_sum_table()

    def compute_gauss_sum_table(self):
        for theta in range(self.q**_sage_const_2  - _sage_const_1 ):
            for alpha in range(self.q - _sage_const_1 ):
                self.table[theta][alpha] = self.compute_gauss_sum(theta, alpha)

    def compute_gauss_sum(self, theta, alpha):
        total = _sage_const_0 
        for x in self.finite_field_multiplicative_group:
            additive_character_value = self.additive_character_generator ** self.trace(x)
            theta_character_value = self.multiplicative_character_generator ** (theta * self.log(x))
            alpha_character_value = self.multiplicative_character_generator ** (alpha * self.get_norm_log(x))
            total += additive_character_value * theta_character_value * alpha_character_value
        return total

    def get_norm_log(self, x):
        return (self.q + _sage_const_1 ) * self.log(x)

    def log(self, x):
        return x.log(self.generator) if x != _sage_const_0  else _sage_const_0 

    def trace(self, x):
        return x.trace()

def complex_gauss_sum_table(q):
    if not is_prime(q):  # Ensure q is a prime number
        raise ValueError("Expected a prime number!")
    return GaussSumTable(q, e ** (_sage_const_2  * pi * I / q), e ** (_sage_const_2  * pi * I / (q**_sage_const_2  - _sage_const_1 )))

def save_gauss_sum_table_as_html(table, filename="complex_gauss_sum_table.html"):
    """
    Saves the Complex Gauss sum table in an HTML file with MathJax LaTeX rendering.
    Groups identical rows together and highlights them.
    """
    colors = [
        "#d1ffd1", "#d1e7ff", "#ffd1d1", "#fff7d1", "#d1fff5", "#ffd1f9", "#e1d1ff", "#ffd9d1"
    ]

    # Find groups of identical rows and build a mapping for reordering
    row_groups = {}
    for i, row in enumerate(table):
        row_tuple = tuple(row)
        if row_tuple in row_groups:
            row_groups[row_tuple]["indices"].append(i)
        else:
            row_groups[row_tuple] = {"indices": [i]}

    # Sort groups by first occurrence and prepare color mapping
    color_map = {}
    ordered_indices = []
    color_index = _sage_const_0 
    
    # First, add single rows (no matches)
    for row_tuple, group in row_groups.items():
        if len(group["indices"]) == _sage_const_1 :
            ordered_indices.extend(group["indices"])
    
    # Then add groups of matching rows
    for row_tuple, group in row_groups.items():
        if len(group["indices"]) > _sage_const_1 :
            for idx in group["indices"]:
                color_map[idx] = colors[color_index % len(colors)]
            ordered_indices.extend(group["indices"])
            color_index += _sage_const_1 

    with open(filename, "w") as f:
        f.write("<html><head><title>Complex Gauss Sum Table</title>\n")
        f.write('<script type="text/javascript" async '
                'src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?'
                'config=TeX-AMS-MML_HTMLorMML"></script>\n')
        f.write('<style>table { border-collapse: collapse; width: 100%; }')
        f.write('th, td { border: 1px solid black; padding: 5px; text-align: center; font-size: 18px; }')
        f.write('th { background-color: #f2f2f2; }</style>\n</head><body>\n')

        f.write("<h2>Complex Gauss Sum Table</h2>\n")
        f.write('<div style="overflow-x:auto;">')
        f.write('<table>\n')

        # Header row
        f.write("<tr><th>\\( \\theta \\backslash \\alpha \\)</th>")
        for alpha in range(len(table[_sage_const_0 ])):
            f.write(f"<th>\\( \\alpha = {alpha} \\)</th>")
        f.write("</tr>\n")

        # Data rows with LaTeX rendering, now in grouped order
        for theta in ordered_indices:
            style = f' style="background-color: {color_map[theta]}"' if theta in color_map else ""
            f.write(f"<tr{style}><td>\\( {theta} \\)</td>")
            for value in table[theta]:
                f.write(f"<td>\\( {latex(value)} \\)</td>")
            f.write("</tr>\n")

        f.write("</table>\n</div>\n</body></html>\n")

    print(f"Saved Complex Gauss Sum Table as {filename}")

def main():
    # Ask the user for a prime number
    while True:
        try:
            user_input = int(input("Enter a prime number (q >= 2): "))
            if user_input < _sage_const_2  or not is_prime(user_input):
                raise ValueError("The number entered is not a prime number or is less than 2.")
            break
        except ValueError as e:
            print(e)
            print("Please enter a valid prime number (q >= 2).")

    # Generate the Gauss Sum Table using user input
    gauss_sum_table_object = complex_gauss_sum_table(user_input)
    table_of_gauss_sum = gauss_sum_table_object.table

    # Save as an HTML file with the new filename
    save_gauss_sum_table_as_html(table_of_gauss_sum, "complex_gauss_sum_table.html")

# Run the program
if __name__ == "__main__":
    main()

