

# This file was *autogenerated* from the file converse_theorem_loop.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3)# This file was *autogenerated* from the file converse_theorem.sage
from sage.all_cmdline import *   # import sage library

# Define Sage Integer constants used throughout the code
_sage_const_2 = Integer(_sage_const_2 ); _sage_const_0 = Integer(_sage_const_0 ); _sage_const_1 = Integer(_sage_const_1 )

# Import necessary functions from Sage
from sage.all import is_prime, carmichael_lambda, GF, expand

# -------------------------------------------------------------------------------------------
# GaussSumTable Class
# -------------------------------------------------------------------------------------------
class GaussSumTable:
    def __init__(self, q, additive_character_generator, multiplicative_character_generator):
        self.q = q
        self.additive_character_generator = additive_character_generator
        self.multiplicative_character_generator = multiplicative_character_generator
        self.finite_field = GF(q**_sage_const_2)
        self.generator = self.finite_field.gen()
        self.finite_field_elements = list(self.finite_field)
        self.finite_field_multiplicative_group = [x for x in self.finite_field_elements if x != _sage_const_0]
        self.table = [
            [_sage_const_0 for _ in range(q - _sage_const_1)]
            for _ in range(q**_sage_const_2 - _sage_const_1)
        ]
        self.compute_gauss_sum_table()

    def compute_gauss_sum_table(self):
        for theta in range(self.q**_sage_const_2 - _sage_const_1):
            for alpha in range(self.q - _sage_const_1):
                self.table[theta][alpha] = self.compute_gauss_sum(theta, alpha)

    def compute_gauss_sum(self, theta, alpha):
        total = _sage_const_0
        for x in self.finite_field_multiplicative_group:
            additive_character_value = self.additive_character_generator**self.trace(x)
            theta_character_value = self.multiplicative_character_generator**(theta * self.log(x))
            alpha_character_value = self.multiplicative_character_generator**(alpha * self.get_norm_log(x))
            total += additive_character_value * theta_character_value * alpha_character_value
        return total

    def get_norm_log(self, x):
        # Norm from GF(q^2) down to GF(q) is x * x^q
        # In the exponent for the character, we use (q+1)*log(x)
        return (self.q + _sage_const_1) * self.log(x)

    def log(self, x):
        return x.log(self.generator) if x != _sage_const_0 else _sage_const_0

    def trace(self, x):
        return x.trace()

    def find_identical_rows(self):
        n = len(self.table)
        visited = set()
        groups = []

        for i in range(n):
            if i in visited:
                continue
            group = [i]
            visited.add(i)
            for j in range(i + _sage_const_1 , n):
                if j in visited:
                    continue
                match = True
                for k in range(len(self.table[i])):
                    # Symbolic difference check
                    if expand(self.table[i][k] - self.table[j][k]) != _sage_const_0 :
                        match = False
                        break
                if match:
                    group.append(j)
                    visited.add(j)
            if len(group) > _sage_const_1 :
                groups.append(group)
        return groups

    def find_counterexamples(self, l, q):
        """
        Return a list of (l, q, identical_groups) if (q-1) is divisible by l
        and there are identical rows.
        identical_groups is sorted by descending group size.
        """
        counterexamples = []
        if (q - _sage_const_1) % l == _sage_const_0:
            identical_groups = self.find_identical_rows()
            if identical_groups:
                identical_groups = sorted(identical_groups, key=len, reverse=True)
                counterexamples.append((l, q, identical_groups))
        return counterexamples

# -------------------------------------------------------------------------------------------
# Helper Functions
# -------------------------------------------------------------------------------------------
def fL_bar_gauss_sum_table(q, l):
    if not is_prime(l):
        raise ValueError("l must be a prime number!")
    prime_power_result = q.is_prime_power(get_data=True)
    if prime_power_result[_sage_const_1] == _sage_const_0:
        raise ValueError("Expected q to be a prime power!")
    p = prime_power_result[_sage_const_0]
    N = p * (q*q - _sage_const_1)
    m = max_power(N, l)
    N_prime = N // (l**m)
    c = carmichael_lambda(N_prime)
    F = GF(l**c)
    h = F.gen()
    return GaussSumTable(
        q,
        h**((l**c - _sage_const_1) // p),
        h**((p * (l**c - _sage_const_1)) // N_prime)
    )

def max_power(N, l):
    m = _sage_const_0
    while N % l == _sage_const_0:
        N //= l
        m += _sage_const_1
    return m

def is_q_of_the_form_1_plus_2_l_j(q, l):
    """
    Return True if q == 1 + 2*(l^j) for some j >= 1.
    Otherwise, return False.
    """
    if q <= _sage_const_1 :
        return False
    diff = q - _sage_const_1 
    # Must be divisible by 2
    if diff % _sage_const_2  != _sage_const_0 :
        return False
    diff //= _sage_const_2 
    # Now check if 'diff' is a power of l
    if diff == _sage_const_0 :
        return False
    while diff % l == _sage_const_0 :
        diff //= l
    return (diff == _sage_const_1 )

# -------------------------------------------------------------------------------------------
# MAIN ENTRY POINT (Loop over all l, q in the given ranges)
# -------------------------------------------------------------------------------------------
# MAIN ENTRY POINT (Loop over all l, q in the given ranges)
if __name__ == "__main__":
    # Prompt for upper bounds instead of single values
    l_upper = Integer(input("Enter the upper bound for prime l: "))
    q_upper = Integer(input("Enter the upper bound for prime-power q: "))

    # This will store rows for our final table:
    # (l_val, q_val, largest_group_size, form_check_boolean)
    table_rows = []

    # Loop over all primes l in [2, l_upper]
    for l_candidate in range(_sage_const_2 , l_upper + _sage_const_1 ):
        # Convert l_candidate to a Sage Integer
        l_val = Integer(l_candidate)
        if is_prime(l_val):
            # Loop over all integers q_candidate in [2, q_upper]
            for q_candidate in range(_sage_const_2 , q_upper + _sage_const_1 ):
                # Convert q_candidate to a Sage Integer
                q_candidate_sage = Integer(q_candidate)
                # Check if q_candidate is indeed a prime power using Sage method:
                prime_power_data = q_candidate_sage.is_prime_power(get_data=True)
                if prime_power_data[_sage_const_1 ] != _sage_const_0 :
                    # Now q_val is a Sage Integer
                    q_val = q_candidate_sage

                    # Build the GaussSumTable object and look for identical groups
                    gauss_sum_table_object = fL_bar_gauss_sum_table(q_val, l_val)
                    counterexamples = gauss_sum_table_object.find_counterexamples(l_val, q_val)

                    # counterexamples is a list of tuples (l, q, identical_groups)
                    for (_, _, identical_groups) in counterexamples:
                        # The identical_groups are sorted by descending size
                        largest_size = len(identical_groups[_sage_const_0 ])  # size of the first group
                        # We only care if largest_size >= 3
                        if largest_size >= _sage_const_3 :
                            # Check if q is of the form 1 + 2*l^j
                            form_check = is_q_of_the_form_1_plus_2_l_j(q_val, l_val)
                            table_rows.append((l_val, q_val, largest_size, form_check))

    # Now print the summary table
    if table_rows:
        # Sort rows by (l, q) or as you prefer:
        table_rows.sort(key=lambda row: (row[_sage_const_0 ], row[_sage_const_1 ]))

        print("\nCounterexamples (where largest identical group has size >= 3)\n")
        print("-------------------------------------------------------------------------------")
        print("|  (l, q)     |  Largest Group Size  |  q = 1 + 2 l^j ?  |")
        print("-------------------------------------------------------------------------------")
        for (l_val, q_val, size_val, bool_val) in table_rows:
            print(f"|  ({l_val}, {q_val})  |         {size_val:<3}           |       {bool_val}       |")
        print("-------------------------------------------------------------------------------")
    else:
        print("No counterexamples with group size >= 3 found in the given ranges.")

