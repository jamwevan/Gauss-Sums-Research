

# This file was *autogenerated* from the file converse_theorem_info.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_100 = Integer(100)# This file was *autogenerated* from the file converse_theorem.sage
from sage.all_cmdline import *   # import sage library

# Define Sage Integer constants used throughout the code
_sage_const_2 = Integer(_sage_const_2 ); _sage_const_0 = Integer(_sage_const_0 ); _sage_const_1 = Integer(_sage_const_1 )

# Import necessary functions from Sage
from sage.all import is_prime, carmichael_lambda, GF

# Class to compute the Gauss Sum Table over a finite field
class GaussSumTable:
    def __init__(self, q, additive_character_generator, multiplicative_character_generator):
        self.q = q
        self.additive_character_generator = additive_character_generator
        self.multiplicative_character_generator = multiplicative_character_generator
        self.finite_field = GF(q**_sage_const_2)
        self.generator = self.finite_field.gen()
        self.finite_field_elements = list(self.finite_field)
        self.finite_field_multiplicative_group = [x for x in self.finite_field_elements if x != _sage_const_0]
        self.table = [[_sage_const_0 for _ in range(q - _sage_const_1)] for _ in range(q**_sage_const_2 - _sage_const_1)]
        self.compute_gauss_sum_table()

    # Compute the full Gauss sum table
    def compute_gauss_sum_table(self):
        for theta in range(self.q**_sage_const_2 - _sage_const_1):
            for alpha in range(self.q - _sage_const_1):
                self.table[theta][alpha] = self.compute_gauss_sum(theta, alpha)

    # Compute a single Gauss sum for given (theta, alpha)
    def compute_gauss_sum(self, theta, alpha):
        total = _sage_const_0
        for x in self.finite_field_multiplicative_group:
            additive_character_value = self.additive_character_generator**self.trace(x)
            theta_character_value = self.multiplicative_character_generator**(theta * self.log(x))
            alpha_character_value = self.multiplicative_character_generator**(alpha * self.get_norm_log(x))
            total += additive_character_value * theta_character_value * alpha_character_value
        return total

    # Compute the norm logarithm of an element in GF(q^2)
    def get_norm_log(self, x):
        return (self.q + _sage_const_1) * self.log(x)

    # Compute the logarithm of an element relative to the field generator
    def log(self, x):
        return x.log(self.generator) if x != _sage_const_0 else _sage_const_0

    # Compute the trace function from GF(q^2) to GF(q)
    def trace(self, x):
        return x.trace()
    
    # Find groups of identical rows in the Gauss sum table
    def find_identical_rows(self):
        row_patterns = {}
        for theta, row in enumerate(self.table):
            row_tuple = tuple(sorted(row))
            row_counts = tuple(sorted([row.count(v) for v in set(row)]))
            key = (row_tuple, row_counts)
            
            # Store theta values instead of just row indices
            if key in row_patterns:
                row_patterns[key].append(theta)
            else:
                row_patterns[key] = [theta]

        # Extract only those groups that have more than one identical row
        identical_groups = [theta_values for theta_values in row_patterns.values() if len(theta_values) > _sage_const_1 ]
        return identical_groups

    # Find counterexamples where the converse theorem fails
    def find_counterexamples(self, l, q):
        counterexamples = []
        if (q - _sage_const_1) % l == _sage_const_0:
            identical_groups = self.find_identical_rows()
            if identical_groups:
                # Sort the groups in descending order of size
                identical_groups = sorted(identical_groups, key=len, reverse=True)
                counterexamples.append((l, q, identical_groups))
        return counterexamples

# Construct a Gauss sum table for given q and l
def fL_bar_gauss_sum_table(q, l):
    if not is_prime(l):
        raise ValueError("l must be a prime number!")
    prime_power_result = q.is_prime_power(get_data=True)
    if prime_power_result[_sage_const_1] == _sage_const_0:
        raise ValueError("Expected a prime power!")
    
    p = prime_power_result[_sage_const_0]
    N = p * (q*q - _sage_const_1)
    m = max_power(N, l)
    N_prime = N // (l**m)
    c = carmichael_lambda(N_prime)
    F = GF(l**c)
    h = F.gen()
    return GaussSumTable(q, h**((l**c - _sage_const_1) // p), h**((p * (l**c - _sage_const_1)) // N_prime))

# Compute the highest power of l that divides N
def max_power(N, l):
    m = _sage_const_0
    while N % l == _sage_const_0:
        N //= l
        m += _sage_const_1
    return m

# Main execution block
if __name__ == "__main__":
    l = Integer(input("Enter a prime l: "))
    q = Integer(input("Enter a prime power q: "))

    
    gauss_sum_table_object = fL_bar_gauss_sum_table(q, l)
    
    counterexamples = gauss_sum_table_object.find_counterexamples(l, q)
    
    # Print the results in table form
    print("\nCounterexamples where the converse theorem fails:")
    for l, q, identical_groups in counterexamples:
        print(f"l = {l}, q = {q}")
        print("\nIdentical Theta Groups (Sorted by Size):")
        print("-" * _sage_const_100 )
        print(f"{'Size':<10}{'Identical Theta Group'}")
        print("-" * _sage_const_100 )
        for group in identical_groups:
            print(f"{len(group):<10}{group}")
        print("-" * _sage_const_100 )

